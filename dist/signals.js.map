{"version":3,"sources":["../src/signals.ts"],"names":["globalStore","getSignal","key","initialValue","signal","hasSignal","deleteSignal","clearSignals","getSignalKeys","createStore","initialState","actions","state","boundActions","args","result","batch","callback","effect","WidgetContextInternal","createContext","WidgetProvider","useWidgetContext","useContext","useGlobalSignal","createDerived","fn","computed"],"mappings":";AAgBA,IAAMA,EAA2B,IAAI,GAAA,CAK9B,SAASC,CAAAA,CAAaC,CAAAA,CAAaC,EAA4B,CACpE,OAAKH,EAAY,GAAA,CAAIE,CAAG,GACtBF,CAAAA,CAAY,GAAA,CAAIE,EAAKE,MAAAA,CAAOD,CAAY,CAAC,CAAA,CAEpCH,CAAAA,CAAY,GAAA,CAAIE,CAAG,CAC5B,CAKO,SAASG,CAAAA,CAAUH,CAAAA,CAAsB,CAC9C,OAAOF,CAAAA,CAAY,IAAIE,CAAG,CAC5B,CAKO,SAASI,CAAAA,CAAaJ,EAAsB,CACjD,OAAOF,EAAY,MAAA,CAAOE,CAAG,CAC/B,CAKO,SAASK,CAAAA,EAAqB,CACnCP,CAAAA,CAAY,KAAA,GACd,CAKO,SAASQ,GAA0B,CACxC,OAAO,KAAA,CAAM,IAAA,CAAKR,CAAAA,CAAY,IAAA,EAAM,CACtC,CAoBO,SAASS,CAAAA,CACdC,CAAAA,CACAC,EACa,CACb,IAAMC,CAAAA,CAAQR,MAAAA,CAAUM,CAAY,CAAA,CAE9BG,EAAe,EAAC,CAEtB,QAAWX,CAAAA,IAAOS,CAAAA,CACfE,EAAqBX,CAAG,CAAA,CAAI,IAAIY,CAAAA,GAAgB,CAC/C,IAAMC,CAAAA,CAASJ,CAAAA,CAAQT,CAAG,CAAA,CAAEU,CAAAA,CAAM,MAAK,CAAG,GAAGE,CAAI,CAAA,CAC7CC,CAAAA,GAAW,MAAA,EACbC,MAAM,IAAM,CACVJ,EAAM,KAAA,CAAQ,CAAE,GAAGA,CAAAA,CAAM,IAAA,GAAQ,GAAGG,CAAO,EAC7C,CAAC,EAEL,EAWF,OAAO,CACL,MAAAH,CAAAA,CACA,OAAA,CAASC,CAAAA,CACT,SAAA,CAXiBI,CAAAA,EACVC,MAAAA,CAAO,IAAM,CAClBD,CAAAA,CAASL,EAAM,KAAK,EACtB,CAAC,CAAA,CASD,WAAA,CANkB,IAASA,CAAAA,CAAM,IAAA,EAOnC,CACF,KAeMO,CAAAA,CAAwBC,aAAAA,CAAoC,IAAI,CAAA,CAEzDC,CAAAA,CAAiBF,CAAAA,CAAsB,SAK7C,SAASG,CAAAA,EAAyD,CACvE,OAAOC,UAAAA,CAAWJ,CAAqB,CACzC,CAKO,SAASK,CAAAA,CAAmBtB,CAAAA,CAAaC,CAAAA,CAA4B,CAC1E,OAAOF,CAAAA,CAAUC,EAAKC,CAAY,CACpC,CASO,SAASsB,CAAAA,CAAiBC,EAAgC,CAC/D,OAAOC,QAAAA,CAASD,CAAE,CACpB","file":"signals.js","sourcesContent":["/**\n * Preact Habitat Modern - Signals Integration\n *\n * Optional module for using @preact/signals with habitat widgets.\n * Enables reactive state sharing between widgets without prop drilling.\n */\n\nimport { signal, computed, effect, batch, Signal, ReadonlySignal } from '@preact/signals';\nimport { useSignal, useComputed, useSignalEffect } from '@preact/signals';\n\n// ============================================================================\n// Signal Store for Cross-Widget State\n// ============================================================================\n\ntype SignalStore = Map<string, Signal<unknown>>;\n\nconst globalStore: SignalStore = new Map();\n\n/**\n * Get or create a global signal by key\n */\nexport function getSignal<T>(key: string, initialValue: T): Signal<T> {\n  if (!globalStore.has(key)) {\n    globalStore.set(key, signal(initialValue));\n  }\n  return globalStore.get(key) as Signal<T>;\n}\n\n/**\n * Check if a signal exists in the global store\n */\nexport function hasSignal(key: string): boolean {\n  return globalStore.has(key);\n}\n\n/**\n * Remove a signal from the global store\n */\nexport function deleteSignal(key: string): boolean {\n  return globalStore.delete(key);\n}\n\n/**\n * Clear all signals from the global store\n */\nexport function clearSignals(): void {\n  globalStore.clear();\n}\n\n/**\n * Get all signal keys\n */\nexport function getSignalKeys(): string[] {\n  return Array.from(globalStore.keys());\n}\n\n// ============================================================================\n// Reactive Store Pattern\n// ============================================================================\n\nexport interface StoreActions<S> {\n  [key: string]: (state: S, ...args: any[]) => Partial<S> | void;\n}\n\nexport interface Store<S, A extends StoreActions<S>> {\n  state: Signal<S>;\n  actions: { [K in keyof A]: (...args: Parameters<A[K]> extends [S, ...infer R] ? R : never[]) => void };\n  subscribe: (callback: (state: S) => void) => () => void;\n  getSnapshot: () => S;\n}\n\n/**\n * Create a reactive store with actions\n */\nexport function createStore<S extends object, A extends StoreActions<S>>(\n  initialState: S,\n  actions: A\n): Store<S, A> {\n  const state = signal<S>(initialState);\n\n  const boundActions = {} as Store<S, A>['actions'];\n\n  for (const key in actions) {\n    (boundActions as any)[key] = (...args: any[]) => {\n      const result = actions[key](state.peek(), ...args);\n      if (result !== undefined) {\n        batch(() => {\n          state.value = { ...state.peek(), ...result };\n        });\n      }\n    };\n  }\n\n  const subscribe = (callback: (state: S) => void): (() => void) => {\n    return effect(() => {\n      callback(state.value);\n    });\n  };\n\n  const getSnapshot = (): S => state.peek();\n\n  return {\n    state,\n    actions: boundActions,\n    subscribe,\n    getSnapshot,\n  };\n}\n\n// ============================================================================\n// Widget Context with Signals\n// ============================================================================\n\nimport { createContext } from 'preact';\nimport { useContext } from 'preact/hooks';\n\nexport interface WidgetContext<T = unknown> {\n  id: string;\n  data: Signal<T>;\n  parentData?: Signal<unknown>;\n}\n\nconst WidgetContextInternal = createContext<WidgetContext | null>(null);\n\nexport const WidgetProvider = WidgetContextInternal.Provider;\n\n/**\n * Hook to access widget context\n */\nexport function useWidgetContext<T = unknown>(): WidgetContext<T> | null {\n  return useContext(WidgetContextInternal) as WidgetContext<T> | null;\n}\n\n/**\n * Hook to create a reactive connection to a global signal\n */\nexport function useGlobalSignal<T>(key: string, initialValue: T): Signal<T> {\n  return getSignal(key, initialValue);\n}\n\n// ============================================================================\n// Computed Values for Derived State\n// ============================================================================\n\n/**\n * Create a computed value that derives from multiple signals\n */\nexport function createDerived<T>(fn: () => T): ReadonlySignal<T> {\n  return computed(fn);\n}\n\n// ============================================================================\n// Re-exports from @preact/signals\n// ============================================================================\n\nexport {\n  signal,\n  computed,\n  effect,\n  batch,\n  useSignal,\n  useComputed,\n  useSignalEffect,\n};\n\nexport type {\n  Signal,\n  ReadonlySignal,\n};\n"]}