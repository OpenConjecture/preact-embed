import {signal,batch,effect,computed}from'@preact/signals';export{batch,computed,effect,signal,useComputed,useSignal,useSignalEffect}from'@preact/signals';import {createContext}from'preact';import {useContext}from'preact/hooks';/* preact-embed | MIT License */
var e=new Map;function d(t,n){return e.has(t)||e.set(t,signal(n)),e.get(t)}function h(t){return e.has(t)}function W(t){return e.delete(t)}function w(){e.clear();}function R(){return Array.from(e.keys())}function P(t,n){let o=signal(t),i={};for(let r in n)i[r]=(...l)=>{let a=n[r](o.peek(),...l);a!==void 0&&batch(()=>{o.value={...o.peek(),...a};});};return {state:o,actions:i,subscribe:r=>effect(()=>{r(o.value);}),getSnapshot:()=>o.peek()}}var S=createContext(null),M=S.Provider;function j(){return useContext(S)}function E(t,n){return d(t,n)}function G(t){return computed(t)}export{M as WidgetProvider,w as clearSignals,G as createDerived,P as createStore,W as deleteSignal,d as getSignal,R as getSignalKeys,h as hasSignal,E as useGlobalSignal,j as useWidgetContext};//# sourceMappingURL=signals.js.map
//# sourceMappingURL=signals.js.map